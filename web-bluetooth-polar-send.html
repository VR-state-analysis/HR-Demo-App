<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>RR Intervals via Web Bluetooth</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    body {
      font-family: system-ui;
    }
    .controls, .stats {
      display: flex;
    }
    .controls > *, .stats > * {
      margin: 8px;
      padding: 6px;
    }
    #status {
      font-weight: bold;
    }
    #deviceName {
      font-weight: bold;
    }
    .stat {
      font-variant-numeric: tabular-nums;
      font-weight: bold;
    }
  </style>
</head>
<body>
  <h1>RR Interval Collector</h1>
  <p>
    Connect your Polar H10.
    Once connected, this webapp will start streaming the Heart Rate Measurement characteristic (0x2A37) data to the server.
  </p>

  <div class="controls">
    <button id="connectBtn">Connect</button>
    <button id="disconnectBtn" disabled>Disconnect</button>
    <button id="clearBtn" disabled>Clear log</button>
    <button id="exportBtn" disabled>Export CSV</button>
  </div>

  <span id="status" role="status">Idle</span>

  <div class="stats">
    <div>
      <div>Device</div>
      <div id="deviceName">—</div>
      <button id="deviceName_copyBtn">Copy</button>
    </div>
    <div>
      <div>Upload Key</div>
      <div id="uploadKey">—</div>
      <button id="uploadKey_copyBtn">Copy</button>
    </div>
    <div>
      <div>Heart Rate</div>
      <div id="bpm" class="stat">—</div>
    </div>
    <div>
      <div>Last RR Interval</div>
      <div id="rrms" class="stat">—</div>
      <div>ms</div>
    </div>
    <div>
      <div>Samples</div>
      <div id="sampleCount" class="stat">0</div>
    </div>
  </div>

  <details open>
    <summary><strong>Live RR log</strong></summary>
    <div id="log">
      <table>
        <thead>
          <tr>
            <th>Timestamp (ISO)</th>
            <th>BPM</th>
            <th>RR (s)</th>
            <th>RR (ms)</th>
          </tr>
        </thead>
        <tbody id="logBody"></tbody>
      </table>
    </div>
  </details>

  <script>
    // --- BLE constants (standardized aliases supported by Web Bluetooth) ---
    const HEART_RATE_SERVICE = 'heart_rate';                     // 0x180D
    const HR_MEASUREMENT_CHAR = 'heart_rate_measurement';        // 0x2A37

    // --- Elements ---
    const statusElem = document.getElementById('status');
    const logElem = document.getElementById('log');
    const logBodyElem = document.getElementById('logBody');
    const deviceNameElem = document.getElementById('deviceName');
    const uploadKeyElem = document.getElementById('uploadKey');
    const bpmElem = document.getElementById('bpm');
    const rrmsElem = document.getElementById('rrms');
    const sampleCountElem = document.getElementById('sampleCount');
    const connectBtn = document.getElementById('connectBtn');
    const disconnectBtn = document.getElementById('disconnectBtn');
    const clearBtn = document.getElementById('clearBtn');
    const exportBtn = document.getElementById('exportBtn');
    const deviceName_copyBtn = document.getElementById('deviceName_copyBtn');
    const uploadKey_copyBtn = document.getElementById('uploadKey_copyBtn');

    // --- State ---
    let device = null;
    let server = null;
    let hrChar = null;
    let rrLog = []; // { tsISO, bpm, rr_s, rr_ms }
    let uploadSession = null;

    // --- UI helpers ---
    const setStatus = (text) => { statusElem.textContent = text; };
    const setEnabled = (ids, enabled) => ids.forEach(id => document.getElementById(id).disabled = !enabled);

    const fmt = (n, digits=0) => (Number.isFinite(n) ? n.toFixed(digits) : '—');

    function appendRow({ tsISO, bpm, rr_s, rr_ms }) {
      const tr = document.createElement('tr');
      const c1 = document.createElement('td'); c1.textContent = tsISO;
      const c2 = document.createElement('td'); c2.textContent = fmt(bpm, 0);
      const c3 = document.createElement('td'); c3.textContent = fmt(rr_s, 3);
      const c4 = document.createElement('td'); c4.textContent = fmt(rr_ms, 1);
      tr.append(c1, c2, c3, c4);
      logBodyElem.appendChild(tr);
      logElem.scrollTop = logElem.scrollHeight; // Keep the log scrolled to bottom
    }

    function updateStatsDisplay(bpm, lastRRms) {
      bpmElem.textContent = Number.isFinite(bpm) ? Math.round(bpm) : '—';
      rrmsElem.textContent = Number.isFinite(lastRRms) ? lastRRms.toFixed(1) : '—';
      sampleCountElem.textContent = rrLog.length;
      // rolling mean of last 10
      const slice = rrLog.slice(-10);
      const mean = slice.length
        ? slice.reduce((s, x) => s + x.rr_ms, 0) / slice.length
        : NaN;
    }

    // --- Upload helpers ---
    function newUploadSession() {
      return fetch('/api/new-upload-key', { method: 'POST' })
        .then((response) => {
          if (!response.ok) {
            throw new Error('Failed to obtain upload key: ' + response.status);
          }
          return response.json();
        })
        .then((data) => {
          if (!data || typeof data.upload_key !== 'string' || data.upload_key.length === 0) {
            throw new Error('Malformed upload key response');
          }
          return { key: data.upload_key, name: data.name };
        })
        .catch((error) => {
          console.error('Unable to initialize upload session', error);
          throw error;
        });
    }

    function uploadRecords(entries, session) {
      if (entries.length === 0) {
        return;
      }
      const body = entries.map(JSON.stringify).join('\n');
      if (!session.key) {
        console.error('No upload key available for upload');
        return;
      }

      const url = '/api/upload?upload_key=' + encodeURIComponent(session.key);

      return fetch(url, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/x-ndjson'
        },
        body: body
      })
        .then((response) => {
          if (!response.ok) {
            throw new Error('Unexpected response status ' + response.status);
          }
          return response.text().catch(() => '');
        })
        .then(() => {
          this.markRecordsUploaded(entries);
        })
        .catch((error) => {
          console.error('Failed to upload records', error);
        });
    }

    // --- BLE flow ---
    async function connect() {
      try {
        setStatus('Requesting device…');

        const deviceOptions = {
          filters: [
            { services: [HEART_RATE_SERVICE] },
          ],
          optionalServices: [HEART_RATE_SERVICE] // needed if a namePrefix match doesn't advertise services in the ad packet
        };

        device = await navigator.bluetooth.requestDevice(deviceOptions);
        device.addEventListener('gattserverdisconnected', onDisconnected);

        deviceNameElem.textContent = device.name || '(Unnamed)';
        setStatus('Connecting…');
        server = await device.gatt.connect();

        const service = await server.getPrimaryService(HEART_RATE_SERVICE);
        hrChar = await service.getCharacteristic(HR_MEASUREMENT_CHAR);

        await hrChar.startNotifications();
        hrChar.addEventListener('characteristicvaluechanged', onHeartRateMeasurement);

        setEnabled(['disconnectBtn', 'clearBtn', 'exportBtn'], true);
        setEnabled(['connectBtn'], false);
        setStatus('Streaming HR + RR');
      } catch (err) {
        console.error(err);
        setStatus('Error: ' + (err?.message || err));
        cleanupPartial();
      }
    }

    async function disconnect() {
      try {
        if (hrChar) {
          hrChar.removeEventListener('characteristicvaluechanged', onHeartRateMeasurement);
          try { await hrChar.stopNotifications(); } catch (_) {}
        }
        if (device?.gatt?.connected) {
          device.gatt.disconnect();
        }
      } finally {
        setStatus('Disconnected');
        setEnabled(['connectBtn'], true);
        setEnabled(['disconnectBtn'], false);
      }
    }

    function onDisconnected() {
      setStatus('Disconnected');
      setEnabled(['connectBtn'], true);
      setEnabled(['disconnectBtn'], false);
    }

    function cleanupPartial() {
      hrChar = null; server = null;
      if (device && device.gatt && device.gatt.connected) {
        try { device.gatt.disconnect(); } catch (_) {}
      }
      setEnabled(['connectBtn'], true);
      setEnabled(['disconnectBtn'], false);
    }

    // --- Parser for Heart Rate Measurement (0x2A37) ---
    // Spec: flags in byte 0
    // bit0: HR format (0=uint8,1=uint16)
    // bit3: Energy Expended present (uint16)
    // bit4: RR-Interval present (one or more uint16, little-endian), units: 1/1024 s
    function parseHeartRateValue(dataView) {
      const flags = dataView.getUint8(0);
      const hrIsUInt16   = (flags & 0x01) !== 0;
      const energyPresent= (flags & 0x08) !== 0;
      const rrPresent    = (flags & 0x10) !== 0;

      let index = 1;
      const bpm = hrIsUInt16
        ? dataView.getUint16(index, true)
        : dataView.getUint8(index);
      index += hrIsUInt16 ? 2 : 1;

      if (energyPresent) {
        index += 2;
      }

      const rrSeconds = [];
      if (rrPresent) {
        while (index + 1 < dataView.byteLength) {
          const rr1024 = dataView.getUint16(index, true);
          rrSeconds.push(rr1024 / 1024); // convert to seconds
          index += 2;
        }
      }

      return { bpm, rrSeconds };
    }

    function onHeartRateMeasurement(event) {
      const dv = event.target.value;
      const { bpm, rrSeconds } = parseHeartRateValue(dv);

      // For each RR interval contained in this notification (there can be multiple):
      const tsISO = new Date().toISOString();
      rrSeconds.forEach(rr_s => {
        const rr_ms = rr_s * 1000;
        const entry = { tsISO, bpm, rr_s, rr_ms };
        rrLog.push(entry);
        appendRow(entry);
        uploadRecords([entry], uploadSession);
      });

      // Update headline stats using the last RR in this packet if any.
      const lastRRms = rrSeconds.length ? rrSeconds[rrSeconds.length - 1] * 1000 : NaN;
      updateStatsDisplay(bpm, lastRRms);
    }

    // --- Actions ---
    function clearLog() {
      rrLog = [];
      logBodyElem.innerHTML = '';
      updateStatsDisplay(NaN, NaN);
      sampleCountElem.textContent = '0';
    }

    function exportCSV() {
      const header = 'timestamp_iso,bpm,rr_s,rr_ms\n';
      const body = rrLog.map(r =>
        `${r.tsISO},${Math.round(r.bpm)},${r.rr_s.toFixed(6)},${r.rr_ms.toFixed(3)}`
      ).join('\n');
      const blob = new Blob([header + body], { type: 'text/csv;charset=utf-8' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `polar-h10-rr-${new Date().toISOString().replace(/[:.]/g,'-')}.csv`;
      document.body.appendChild(a);
      a.click();
      a.remove();
      URL.revokeObjectURL(url);
    }

    // --- Wire up UI ---
    connectBtn.addEventListener('click', async () => {
      if (!('bluetooth' in navigator)) {
        setStatus('Web Bluetooth not supported in this browser.');
        return;
      }
      uploadSession = await newUploadSession();
      uploadKeyElem.textContent = uploadSession.name;
      await connect();
    });

    disconnectBtn.addEventListener('click', disconnect);
    clearBtn.addEventListener('click', clearLog);
    exportBtn.addEventListener('click', exportCSV);

    deviceName_copyBtn.addEventListener('click', async () => {
      try {
        await navigator.clipboard.writeText(deviceNameElem.textContent);
        setStatus('Copied device name to clipboard.');
      } catch (e) {
        setStatus('Failed to copy.');
      }
    });
    uploadKey_copyBtn.addEventListener('click', async () => {
      try {
        await navigator.clipboard.writeText(uploadKeyElem.textContent);
        setStatus('Copied upload key to clipboard.');
      } catch (e) {
        setStatus('Failed to copy.');
      }
    });
  </script>

  <hr />
</body>
</html>
