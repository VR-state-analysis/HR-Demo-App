<html>
  <head>
    <script src="https://aframe.io/releases/1.7.0/aframe.min.js"></script>
    <script>
      AFRAME.registerComponent('headset-pos-vel', {
        schema: { target: { type: 'selector' } },
        init: function () {
          this.cameraEl = null;
          this.textEl = null;
          this.prevTime = null;
          this.trackers = {};
          this.cache = { leftHand: null, rightHand: null };
          this.currentText = '';
          this.records = [];
          this.recordCount = 0;
          this.uploadSession = { key: null, name: null };
          this.boundUnloadHandler = null;
          this.uploadInterval = setInterval(this.uploadPendingRecords.bind(this), 3000);
        },
        update: function () {
          this.textEl = this.data.target || this.el.querySelector('a-text');
        },
        updateCamera: function () {
          if (this.cameraEl) { return; }
          const sceneEl = this.el.sceneEl;
          if (sceneEl && sceneEl.camera && sceneEl.camera.el) {
            this.cameraEl = sceneEl.camera.el;
          }
        },
        getTracker: function (key) {
          if (!this.trackers[key]) {
            this.trackers[key] = {
              prevPosition: new THREE.Vector3(),
              currentPosition: new THREE.Vector3(),
              velocity: new THREE.Vector3(),
              lastSavedPosition: new THREE.Vector3(),
              hasPrev: false,
              hasSaved: false
            };
          }
          return this.trackers[key];
        },
        formatVector: function (vec) {
          return vec.x.toFixed(2) + ', ' + vec.y.toFixed(2) + ', ' + vec.z.toFixed(2);
        },
        resolveController: function (id) {
          const sceneEl = this.el.sceneEl;
          if (!sceneEl) { return null; }
          const cached = this.cache[id];
          if (cached && cached.isConnected) { return cached; }
          const el = sceneEl.querySelector('#' + id);
          if (el) { this.cache[id] = el; }
          return el;
        },
        ensureUploadSession: function () {
          if (this.uploadSession && this.uploadSession.key) { return Promise.resolve(this.uploadSession); }

          return fetch('/api/new-upload-key', { method: 'POST' })
            .then((response) => {
              if (!response.ok) {
                throw new Error('Failed to obtain upload key: ' + response.status);
              }
              return response.json();
            })
            .then((data) => {
              if (!data || typeof data.upload_key !== 'string' || data.upload_key.length === 0) {
                throw new Error('Malformed upload key response');
              }
              this.uploadSession = { key: data.upload_key, name: data.name || '' };
              return this.uploadSession;
            })
            .catch((error) => {
              console.error('Unable to initialize upload session', error);
              throw error;
            });
        },
        clearUploadLoop: function () {
          if (this.uploadInterval) {
            clearInterval(this.uploadInterval);
            this.uploadInterval = null;
          }
          if (this.boundUnloadHandler) {
            window.removeEventListener('beforeunload', this.boundUnloadHandler);
            this.boundUnloadHandler = null;
          }
        },
        tick: function (time, delta) {
          this.updateCamera();
          if (!this.textEl) { return; }
          const sceneEl = this.el.sceneEl;
          if (!sceneEl) { return; }

          const dt = (this.prevTime !== null && delta > 0) ? delta / 1000 : null;
          const lines = [];

          const leftHandEl = this.resolveController('leftHand');
          const rightHandEl = this.resolveController('rightHand');

          const targets = [
            { label: 'Headset', obj3D: this.cameraEl ? this.cameraEl.object3D : null, key: 'headset' },
            { label: 'Left Ctrl', obj3D: leftHandEl ? leftHandEl.object3D : null, key: 'leftController' },
            { label: 'Right Ctrl', obj3D: rightHandEl ? rightHandEl.object3D : null, key: 'rightController' }
          ];

          for (let i = 0; i < targets.length; i++) {
            const target = targets[i];
            if (!target.obj3D) {
              lines.push(target.label + ': N/A');
              continue;
            }

            const tracker = this.getTracker(target.key);
            target.obj3D.getWorldPosition(tracker.currentPosition);

            if (dt && tracker.hasPrev) {
              tracker.velocity.copy(tracker.currentPosition).sub(tracker.prevPosition).divideScalar(dt);
            } else {
              tracker.velocity.set(0, 0, 0);
            }

            tracker.prevPosition.copy(tracker.currentPosition);
            tracker.hasPrev = true;

            this.records.push({trackerKey: target.key, timestamp: time, position: tracker.currentPosition});

            lines.push(
              target.label + ' Pos (m): ' + this.formatVector(tracker.currentPosition) + '\n' +
              target.label + ' Vel (m/s): ' + this.formatVector(tracker.velocity)
            );
          }

          if (this.uploadSession && this.uploadSession.name) {
            lines.push('Upload name: ' + this.uploadSession.name);
          }

          lines.push('Stored samples: ' + this.recordCount);

          this.prevTime = time;
          const message = lines.join('\n');
          if (message !== this.currentText) {
            this.currentText = message;
            this.textEl.setAttribute('value', message);
          }
        },
        uploadPendingRecords: function () {
          const ourRecords = this.records;
          this.records = [];
          this.recordCount += ourRecords.length;
          this.ensureUploadSession().then((session) => this.postRecords(ourRecords, session));
        },
        postRecords: function (entries, session) {
          const payloadLines = entries.map((entry) => {
            return JSON.stringify({
              trackerKey: entry.value.trackerKey,
              timestamp: entry.value.timestamp,
              position: entry.value.position
            });
          });

          if (payloadLines.length === 0) {
            return;
          }

          const body = payloadLines.join('\n');
          const uploadKey = session && session.key ? session.key : '';
          if (!uploadKey) {
            console.error('No upload key available for upload');
            return;
          }

          const url = '/api/upload?upload_key=' + encodeURIComponent(uploadKey);

          fetch(url, {
            method: 'POST',
            headers: {
              'Content-Type': 'application/x-ndjson'
            },
            body: body
          })
            .then((response) => {
              if (!response.ok) {
                throw new Error('Unexpected response status ' + response.status);
              }
              return response.text().catch(() => '');
            })
            .then(() => {
              this.markRecordsUploaded(entries);
            })
            .catch((error) => {
              console.error('Failed to upload tracker positions', error);
            });
        },
      });
    </script>
  </head>
  <body>
    <a-scene vr-mode-ui="enabled: true">
      <a-box position="-1 0.5 -3" rotation="0 45 0" color="#4CC3D9"></a-box>
      <a-sphere position="0 1.25 -5" radius="1.25" color="#EF2D5E"></a-sphere>
      <a-cylinder position="1 0.75 -3" radius="0.5" height="1.5" color="#FFC65D"></a-cylinder>
      <a-plane position="0 0 -4" rotation="-90 0 0" width="4" height="4" color="#7BC8A4"></a-plane>
      <a-sky color="#ECECEC"></a-sky>
      <a-entity id="showPosVel" position="0 1.2 -2" headset-pos-vel="target: #showPosVelText">
        <a-plane width="1" height="0.3" material="color: #FFFCAB; shader: flat"></a-plane>
        <a-text id="showPosVelText" value="Loading..." align="center" color="#333" width="2" position="0 0 0.02"></a-text>
      </a-entity>
      <a-entity id="leftHand" laser-controls="hand: left" curosr="rayOrigin: entity" raycaster="objects: .clickable; far: 10"></a-entity>
      <a-entity id="rightHand" laser-controls="hand: right" curosr="rayOrigin: entity" raycaster="objects: .clickable; far: 10"></a-entity>
    </a-scene>
  </body>
</html>
